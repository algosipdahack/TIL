### 내가 한 프로젝트
도메인 -> 이벤트 디스패처 -> 로컬핸들러 -> 저장소(mysql) 이벤트 저장
-> 스프링 이벤트로 리스닝한 포워더가 이벤트를 가져옴 -> redis stream에게 전달 -> 해당 채널 구독하던 핸들러가 이벤트 처리

### 이벤트 구성요소
이벤트 생성 주체 -> 이벤트 디스패처(이벤트 퍼블리셔) -> 이벤트 핸들러(이벤트 구독자)
- 이벤트 핸들러는 이벤트 생성주체가 발생한 이벤트에 반응
- 이벤트 디스패처는 핸들러에 이벤트를 전파.
  - 이벤트 디스패처의 구현방식에 따라 이벤트 생성과 처리를 동기/비동기로 실행

### 비동기 이벤트 사용 이유
- 두 시스템 간의 결합을 크게 낮출 수 있다.
  - ex) 사건 발생 후 알림이 가는데, 이 두 시스템의 결합도를 낮춤
- 이메일 인증과 같이 후속 조치를 즉시하는 것이 아니라 일정 시간 안에만 처리하면 되는 경우

### 비동기 이벤트 처리 방법
1. 로컬 핸들러를 비동기로 실행
    - 이벤트 핸들러가 별도의 스레드에서 동작하는 방법
      - 이벤트를 제외한 것들만 트랜잭션으로 묶임
2. 메시징 시스템을 이용한 비동기 구현
- MQ는 이벤트를 메시지 리스너에게 전달 -> 메시지 리스너는 알맞은 이벤트 핸들러를 호출
- 이벤트를 MQ로 보내는 스레드와 MQ에서 이벤트를 읽고 처리하는 스레드는 서로 다름
- 트랜잭션을 하나로 묶어서 MQ에 저장까지 해줘야 함-> 이벤트 핸들링 실패 시에도 MQ에 저장되어 있으니 이벤트 유실X

3. 이벤트 저장소와 포워더를 이용한 비동기 처리
- 이벤트를 DB에 저장 -> 포워더를 이용하여 이벤트 핸들러에 전달
- 포워더는 주기적으로 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행(스케줄링)
  - 포워더는 별도의 스레드를 사용
- 트랜잭션 범위는 DB에 저장까지 -> 핸들러가 이벤트 처리 실패하더라도 재실행 가능


### Reference
---
https://velog.io/@backtony/Spring-Event-Driven
https://colinch4.github.io/2021-06-17/10%EC%9E%A5.-%EC%9D%B4%EB%B2%A4%ED%8A%B8/